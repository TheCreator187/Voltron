<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="VoltronBot - Boost your meme coin volume on Raydium and automate sneaker drops.">
    <meta name="keywords" content="solana volume bot, meme coin booster, raydium trading, sneaker bot">
    <meta name="author" content="CryptoVoltron Team">
    <title>VoltronBot - Meme Coin & Sneaker Automation</title>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;800&family=Orbitron:wght@500;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
    <link href="css/styles.css" rel="stylesheet" type="text/css">
</head>
<body>
    <div class="background">
        <div class="gradient-overlay"></div>
        <div class="grid-lines"></div>
        <div id="particles-js"></div>
    </div>

    <nav class="navbar">
        <a href="#" class="logo">
            <span class="logo-text">VoltronBot</span>
            <span class="logo-subtext">by B TechLabs</span>
        </a>
        <span class="menu-toggle">‚ò∞</span>
        <div class="nav-links">
            <a href="#home">Home</a>
            <a href="#volume-bot">Volume Bot</a>
            <a href="#sneaker-bot" class="highlight-link">Sneaker Bot</a>
            <a href="#signup">Sign Up</a>
            <a href="#contact">Contact</a>
        </div>
    </nav>

    <section class="hero" id="home">
        <div class="hero-background">
            <img src="images/space.jpg" alt="Crypto Space Background">
        </div>
        <div class="content">
            <h1>Boost Your Meme Coin & Buy Sneakers</h1>
            <p>Supercharge your meme coin volume on Raydium and buy sneakers from every store for 1 SOL each‚Äîvia Phantom wallet.</p>
            <button id="add-wallet-btn" class="button" onclick="connectWallet()">Connect Phantom Wallet</button>
            <div id="wallet-status" class="wallet-status"></div>
        </div>
    </section>

    <main class="main">
        <section class="volume-bots" id="volume-bot">
            <h2 class="section-title">Meme Coin Volume Booster (Raydium)</h2>
            <p>Boost your meme coin's trading volume on Raydium with AI-driven automation. Fee: 1 SOL.</p>
            <div class="volume-bot-grid">
                <div class="volume-bot-card">
                    <div class="icon">üåê</div>
                    <h3>Solana Raydium Meme Booster</h3>
                    <p>Enhance your meme coin's volume with randomized trades, multi-wallet rotation, and Jito-powered speed.</p>
                    <form class="volume-bot-form" data-type="solana-raydium-meme">
                        <input type="text" name="tokenMint" placeholder="Meme Coin Mint Address" required>
                        <input type="number" name="volume" placeholder="Target Volume (SOL)" min="1" required>
                        <input type="number" name="wallets" placeholder="Number of Wallets (1-20)" min="1" max="20" required>
                        <input type="number" name="profitThreshold" placeholder="Profit Sell % (e.g., 50)" min="0" required>
                        <button type="submit" class="button">Boost Volume</button>
                    </form>
                    <div class="volume-bot-status"></div>
                    <div class="liquidity-info" id="liquidity-info"></div>
                </div>
            </div>
        </section>

        <section class="sneaker-bot modern-section" id="sneaker-bot">
            <h2 class="section-title sneaker-title">Sneaker Bot Arsenal</h2>
            <p class="section-subtitle">Purchase sneakers from any store with cutting-edge automation. Fee: 1 SOL per attempt.</p>
            <div class="sneaker-bot-container">
                <form id="sneaker-bot-form" class="sneaker-bot-form modern-form">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="sites">Search Stores</label>
                            <select name="sites" id="sites" multiple required>
                                <option value="nike">Nike</option>
                                <option value="adidas">Adidas</option>
                                <option value="footlocker">Footlocker</option>
                                <option value="stockx">StockX</option>
                                <option value="goat">GOAT</option>
                                <option value="supreme">Supreme</option>
                                <option value="kith">Kith</option>
                                <option value="sneakersnstuff">Sneakersnstuff</option>
                                <option value="finishline">Finish Line</option>
                                <option value="jdsports">JD Sports</option>
                                <option value="ebay">eBay</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="sneakerName">Sneaker Name</label>
                            <input type="text" name="sneakerName" id="sneakerName" placeholder="e.g., Air Jordan 1" required>
                        </div>
                        <div class="form-group">
                            <label for="brand">Brand</label>
                            <input type="text" name="brand" id="brand" placeholder="e.g., Nike, Adidas" required>
                        </div>
                        <div class="form-group">
                            <label for="color">Color (Optional)</label>
                            <input type="text" name="color" id="color" placeholder="e.g., Black, White">
                        </div>
                        <div class="form-group">
                            <label for="maxPrice">Max Price (Optional, $)</label>
                            <input type="number" name="maxPrice" id="maxPrice" placeholder="e.g., 200" min="1" step="1">
                        </div>
                        <div class="form-group">
                            <label for="sneaker-url">Selected URL</label>
                            <input type="text" name="url" id="sneaker-url" placeholder="Auto-filled after lookup" readonly>
                        </div>
                        <div class="form-group">
                            <label for="size-select">Size</label>
                            <select name="size" id="size-select" required>
                                <option value="">Select Size</option>
                                <!-- Sizes populated dynamically -->
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="quantity">Quantity</label>
                            <input type="number" name="quantity" id="quantity" placeholder="1-5" min="1" max="5" required>
                        </div>
                        <div class="form-group full-width">
                            <label for="proxies">Proxies (Optional)</label>
                            <textarea name="proxies" id="proxies" placeholder="One per line, e.g., 192.168.1.1:8080" rows="3"></textarea>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="button secondary-button" onclick="lookupSneakers()">Lookup Sneakers</button>
                        <button type="button" class="button secondary-button" onclick="checkStock()">Check Stock</button>
                        <button type="submit" class="button primary-button sneaker-button">Auto-Buy</button>
                    </div>
                </form>
                <div id="sneaker-bot-status" class="status-message"></div>
                <div id="lookup-results" class="lookup-results"></div>
            </div>
        </section>

        <section class="features">
            <h2 class="section-title crypto-title">Supported Cryptocurrency</h2>
            <div class="crypto-grid">
                <div class="crypto-item"><img src="https://raw.githubusercontent.com/spothq/cryptocurrency-icons/master/32/color/sol.png" alt="Solana"><span>Solana (SOL)</span></div>
            </div>
            <p class="crypto-note">Optimized for meme coins on Raydium and sneaker drops from every store!</p>
        </section>

        <section class="signup modern-signup" id="signup">
            <div class="signup-content">
                <h2 class="section-title">Join the Revolution</h2>
                <p class="signup-description">Boost your meme coin volume and buy sneakers from any store for just 1 SOL each via Phantom wallet.</p>
                <form id="signup-form" class="signup-form">
                    <div class="form-group">
                        <input type="email" name="email" class="form-input" placeholder="Enter Your Email" required>
                    </div>
                    <button type="submit" class="button primary-button">Activate Your Account</button>
                </form>
            </div>
        </section>
    </main>

    <footer class="footer modern-footer">
        <div class="footer-content">
            <p>¬© 2025 VoltronBot. All Rights Reserved.</p>
            <div class="social-links">
                <a href="https://x.com" aria-label="X" class="social-link"><i class="fab fa-x-twitter"></i></a>
                <a href="https://discord.com" aria-label="Discord" class="social-link"><i class="fab fa-discord"></i></a>
                <a href="https://telegram.org" aria-label="Telegram" class="social-link"><i class="fab fa-telegram-plane"></i></a>
            </div>
        </div>
    </footer>

    <!-- External Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <script>
        console.log('Script started executing...');

        // Particle.js setup
        if (typeof particlesJS !== 'undefined') {
            particlesJS("particles-js", {
                particles: {
                    number: { value: 120, density: { enable: true, value_area: 800 } },
                    color: { value: "#39ff14" },
                    shape: { type: "polygon", polygon: { nb_sides: 6 } },
                    opacity: { value: 0.7, random: true },
                    size: { value: 3, random: true },
                    line_linked: { enable: true, distance: 100, color: "#ff1a8c", opacity: 0.6, width: 1.2 },
                    move: { enable: true, speed: 2, direction: "none", random: true, straight: false, out_mode: "out" }
                },
                interactivity: {
                    detect_on: "canvas",
                    events: { onhover: { enable: true, mode: "grab" }, onclick: { enable: true, mode: "push" }, resize: true },
                    modes: { grab: { distance: 150, line_linked: { opacity: 0.8 } }, push: { particles_nb: 4 } }
                },
                retina_detect: true
            });
            console.log('Particles.js initialized');
        } else {
            console.error('particlesJS not loaded');
        }

        // Navbar and menu functionality
        window.addEventListener('scroll', () => {
            document.querySelector('.navbar').classList.toggle('sticky', window.scrollY > 0);
        });

        const menuToggle = document.querySelector('.menu-toggle');
        const navLinks = document.querySelector('.nav-links');

        if (menuToggle && navLinks) {
            menuToggle.addEventListener('click', (event) => {
                event.stopPropagation();
                navLinks.classList.toggle('active');
            });

            document.addEventListener('click', (event) => {
                if (!menuToggle.contains(event.target) && !navLinks.contains(event.target)) {
                    navLinks.classList.remove('active');
                }
            });
            console.log('Menu toggle initialized');
        } else {
            console.error('Menu toggle or nav links not found');
        }

        // Signup form
        const signupForm = document.getElementById('signup-form');
        if (signupForm) {
            signupForm.addEventListener('submit', (e) => {
                e.preventDefault();
                alert('Account activated! Welcome to VoltronBot.');
            });
            console.log('Signup form initialized');
        } else {
            console.error('Signup form not found');
        }

        // Wallet connection logic
        const walletButton = document.getElementById('add-wallet-btn');
        const walletStatus = document.getElementById('wallet-status');

        if (!walletButton || !walletStatus) {
            console.error('Wallet button or status element not found');
        } else {
            console.log('Wallet button found, attaching event listener...');
            walletButton.addEventListener('click', () => {
                console.log('Connect Phantom Wallet button clicked (via addEventListener)');
                connectWallet();
            });
        }

        let connectedWallet = null;

        function truncateAddress(address) {
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        async function connectWallet() {
            console.log('connectWallet function called');
            alert('Button clicked! Attempting to connect Phantom wallet...');

            const solProvider = window.solana;
            console.log('Solana provider:', solProvider ? 'Detected' : 'Not Detected');

            if (!solProvider || !solProvider.isPhantom) {
                walletStatus.textContent = 'Please install Phantom wallet.';
                walletStatus.style.color = 'var(--vibe-pink)';
                console.error('Phantom wallet not detected');
                return;
            }

            walletStatus.textContent = 'Connecting Phantom wallet...';
            walletStatus.style.color = 'var(--vibe-cyan)';

            try {
                await solProvider.connect();
                const address = solProvider.publicKey.toString();
                connectedWallet = { type: 'Phantom', address, provider: solProvider };
                walletStatus.textContent = `Connected via Phantom: ${truncateAddress(address)}`;
                walletStatus.style.color = 'var(--neon-lime)';
                console.log('Phantom connected:', address);
            } catch (error) {
                console.error('Wallet connection failed:', error);
                walletStatus.textContent = `Connection failed: ${error.message || 'Unknown error'}`;
                walletStatus.style.color = 'var(--vibe-pink)';
            }
        }

        // Sneaker Bot Functions
        const sneakerBotStatus = document.getElementById('sneaker-bot-status');
        const sizeSelect = document.getElementById('size-select');
        const sneakerBotForm = document.getElementById('sneaker-bot-form');
        const lookupResults = document.getElementById('lookup-results');
        const sneakerUrlInput = document.getElementById('sneaker-url');

        async function lookupSneakers() {
            const sites = Array.from(sneakerBotForm.querySelector('[name="sites"]').selectedOptions).map(opt => opt.value);
            const sneakerName = sneakerBotForm.querySelector('[name="sneakerName"]').value;
            const brand = sneakerBotForm.querySelector('[name="brand"]').value;
            const color = sneakerBotForm.querySelector('[name="color"]').value || '';
            const maxPrice = sneakerBotForm.querySelector('[name="maxPrice"]').value || Infinity;

            sneakerBotStatus.textContent = `Searching for "${sneakerName}" across ${sites.length} stores...`;
            sneakerBotStatus.style.color = 'var(--vibe-cyan)';

            try {
                const allResults = await Promise.all(sites.map(site => fetchSneakerByName(site, sneakerName, brand, color, maxPrice)));
                const flatResults = allResults.flat();
                if (flatResults.length === 0) {
                    sneakerBotStatus.textContent = 'No sneakers found across selected stores.';
                    sneakerBotStatus.style.color = 'var(--vibe-pink)';
                    lookupResults.innerHTML = '';
                    return;
                }

                sneakerBotStatus.textContent = `Found ${flatResults.length} matches! Select one below.`;
                sneakerBotStatus.style.color = 'var(--neon-lime)';
                displayLookupResults(flatResults);
            } catch (error) {
                console.error('Lookup failed:', error);
                sneakerBotStatus.textContent = `Lookup failed: ${error.message}`;
                sneakerBotStatus.style.color = 'var(--vibe-pink)';
            }
        }

        async function fetchSneakerByName(site, name, brand, color, maxPrice) {
            const mockResults = {
                nike: [
                    { name: 'Air Jordan 1', url: 'https://nike.com/air-jordan-1', sizes: ['8', '9', '10'], price: 150, brand: 'Nike', color: 'Black' },
                    { name: 'Air Max 90', url: 'https://nike.com/air-max-90', sizes: ['9', '10', '11'], price: 120, brand: 'Nike', color: 'White' }
                ],
                adidas: [
                    { name: 'Yeezy Boost 350', url: 'https://adidas.com/yeezy-350', sizes: ['7', '8', '9'], price: 220, brand: 'Adidas', color: 'Grey' },
                    { name: 'Ultraboost', url: 'https://adidas.com/ultraboost', sizes: ['8', '9', '10'], price: 180, brand: 'Adidas', color: 'Black' }
                ],
                footlocker: [
                    { name: 'Air Force 1', url: 'https://footlocker.com/air-force-1', sizes: ['9', '10', '11'], price: 100, brand: 'Nike', color: 'White' }
                ],
                stockx: [
                    { name: 'Yeezy Boost 350', url: 'https://stockx.com/yeezy-350', sizes: ['8', '9'], price: 250, brand: 'Adidas', color: 'Grey' }
                ],
                goat: [
                    { name: 'Air Jordan 1', url: 'https://goat.com/air-jordan-1', sizes: ['9', '10'], price: 160, brand: 'Nike', color: 'Black' }
                ],
                supreme: [
                    { name: 'Supreme x Nike SB', url: 'https://supremenewyork.com/sb', sizes: ['10', '11'], price: 200, brand: 'Nike', color: 'Red' }
                ],
                kith: [
                    { name: 'Kith x Adidas', url: 'https://kith.com/adidas', sizes: ['8', '9'], price: 190, brand: 'Adidas', color: 'Blue' }
                ],
                sneakersnstuff: [
                    { name: 'Puma RS-X', url: 'https://sneakersnstuff.com/rs-x', sizes: ['9', '10'], price: 130, brand: 'Puma', color: 'White' }
                ],
                finishline: [
                    { name: 'New Balance 990', url: 'https://finishline.com/990', sizes: ['10', '11'], price: 175, brand: 'New Balance', color: 'Grey' }
                ],
                jdsports: [
                    { name: 'Air Max 95', url: 'https://jdsports.com/air-max-95', sizes: ['8', '9'], price: 170, brand: 'Nike', color: 'Black' }
                ],
                ebay: [
                    { name: 'Air Jordan 1', url: 'https://ebay.com/air-jordan-1', sizes: ['9', '10'], price: 140, brand: 'Nike', color: 'Black' }
                ]
            };

            return new Promise((resolve) => {
                setTimeout(() => {
                    const siteResults = mockResults[site] || [];
                    const filtered = siteResults.filter(item =>
                        item.name.toLowerCase().includes(name.toLowerCase()) &&
                        item.brand.toLowerCase().includes(brand.toLowerCase()) &&
                        (color === '' || item.color.toLowerCase().includes(color.toLowerCase())) &&
                        item.price <= maxPrice
                    );
                    resolve(filtered.map(item => ({ ...item, store: site })));
                }, 1000);
            });
        }

        function displayLookupResults(results) {
            lookupResults.innerHTML = '';
            results.forEach((result, index) => {
                const div = document.createElement('div');
                div.classList.add('lookup-item');
                div.innerHTML = `<span>${result.name} (${result.brand}, ${result.color}) - $${result.price} @ ${result.store}</span> <button class="select-button" onclick="selectSneaker('${result.url}', ${JSON.stringify(result.sizes)}, '${result.store}')">Select</button>`;
                lookupResults.appendChild(div);
            });
        }

        function selectSneaker(url, sizes, store) {
            sneakerUrlInput.value = url;
            sneakerBotForm.querySelector('[name="sites"]').value = [store];
            populateSizes(sizes);
            sneakerBotStatus.textContent = `Selected: ${url} from ${store}`;
            sneakerBotStatus.style.color = 'var(--neon-lime)';
            lookupResults.innerHTML = '';
        }

        async function checkStock() {
            const site = sneakerBotForm.querySelector('[name="sites"]').value[0];
            const url = sneakerBotForm.querySelector('[name="url"]').value;
            sneakerBotStatus.textContent = 'Checking stock availability...';
            sneakerBotStatus.style.color = 'var(--vibe-cyan)';

            try {
                const response = await fetchStock(site, url);
                const { inStock, sizes } = response;

                if (inStock) {
                    sneakerBotStatus.textContent = 'Stock available!';
                    sneakerBotStatus.style.color = 'var(--neon-lime)';
                    populateSizes(sizes);
                } else {
                    sneakerBotStatus.textContent = 'Out of stock.';
                    sneakerBotStatus.style.color = 'var(--vibe-pink)';
                }
            } catch (error) {
                console.error('Stock check failed:', error);
                sneakerBotStatus.textContent = `Stock check failed: ${error.message}`;
                sneakerBotStatus.style.color = 'var(--vibe-pink)';
            }
        }

        function populateSizes(sizes) {
            sizeSelect.innerHTML = '<option value="">Select Size</option>';
            sizes.forEach(size => {
                const option = document.createElement('option');
                option.value = size;
                option.textContent = size;
                sizeSelect.appendChild(option);
            });
        }

        async function fetchStock(site, url) {
            const mockSizes = {
                nike: ['8', '9', '10', '11', '12'],
                adidas: ['7', '8', '9', '10', '11'],
                footlocker: ['9', '10', '11', '12', '13'],
                stockx: ['8', '9', '10'],
                goat: ['9', '10', '11'],
                supreme: ['10', '11', '12'],
                kith: ['8', '9', '10'],
                sneakersnstuff: ['9', '10', '11'],
                finishline: ['10', '11', '12'],
                jdsports: ['8', '9', '10'],
                ebay: ['9', '10', '11']
            };
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({
                        inStock: Math.random() > 0.3,
                        sizes: mockSizes[site] || ['10']
                    });
                }, 1000);
            });
        }

        async function copSneakers(site, url, size, quantity, proxies, status) {
            if (!connectedWallet) {
                status.textContent = 'Please connect your Phantom wallet first.';
                status.style.color = 'var(--vibe-pink)';
                return;
            }

            if (!url) {
                status.textContent = 'Please lookup and select a sneaker first.';
                status.style.color = 'var(--vibe-pink)';
                return;
            }

            status.textContent = 'Initiating 1 SOL payment...';
            status.style.color = 'var(--vibe-cyan)';

            try {
                const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.fm', 'confirmed');
                const walletAddress = new solanaWeb3.PublicKey('YOUR_SOLANA_WALLET_ADDRESS');
                const userPublicKey = new solanaWeb3.PublicKey(connectedWallet.address);

                const transaction = new solanaWeb3.Transaction();
                const lamports = solanaWeb3.LAMPORTS_PER_SOL * 1;
                transaction.add(
                    solanaWeb3.SystemProgram.transfer({
                        fromPubkey: userPublicKey,
                        toPubkey: walletAddress,
                        lamports: lamports,
                    })
                );

                const { blockhash } = await connection.getRecentBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = userPublicKey;

                const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signedTransaction.serialize());
                await connection.confirmTransaction(signature, 'confirmed');

                status.textContent = `Payment successful! Starting cop process... Tx: ${signature}`;
                status.style.color = 'var(--neon-lime)';

                const proxyList = proxies ? proxies.split('\n').filter(p => p.trim()) : [];
                const proxy = proxyList.length ? proxyList[Math.floor(Math.random() * proxyList.length)] : null;

                status.textContent = `Checking stock on ${site}...`;
                const { inStock } = await fetchStock(site, url);
                if (!inStock) throw new Error('Item out of stock');

                status.textContent = `Adding to cart on ${site}...`;
                await simulateDelay(1000, 3000);
                await addToCart(site, url, size, quantity, proxy);

                status.textContent = `Attempting checkout on ${site}...`;
                await simulateDelay(2000, 4000);
                const checkoutSuccess = await checkout(site, url, proxy);

                if (checkoutSuccess) {
                    status.textContent = `Successfully copped ${quantity} pair(s) of size ${size} from ${site}!`;
                    status.style.color = 'var(--neon-lime)';
                    sneakerBotForm.reset();
                } else {
                    status.textContent = `Checkout failed on ${site}. Possible queue or sold out.`;
                    status.style.color = 'var(--vibe-pink)';
                }
            } catch (error) {
                console.error('Copping failed:', error);
                status.textContent = `Failed: ${error.message}`;
                status.style.color = 'var(--vibe-pink)';
            }
        }

        async function simulateDelay(min, max) {
            const delay = Math.floor(Math.random() * (max - min) + min);
            return new Promise(resolve => setTimeout(resolve, delay));
        }

        async function addToCart(site, url, size, quantity, proxy) {
            console.log(`Adding to cart: ${quantity} x ${size} from ${site} via ${proxy || 'no proxy'}`);
            return new Promise(resolve => setTimeout(() => resolve(true), 1000));
        }

        async function checkout(site, url, proxy) {
            console.log(`Checking out from ${site} via ${proxy || 'no proxy'}`);
            return new Promise(resolve => setTimeout(() => resolve(Math.random() > 0.2), 1500));
        }

        // Volume Booster Functions (unchanged)
        async function checkLiquidity(tokenMint) {
            const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.fm', 'confirmed');
            const tokenPublicKey = new solanaWeb3.PublicKey(tokenMint);
            const liquidityInfo = document.getElementById('liquidity-info');

            try {
                const accounts = await connection.getTokenLargestAccounts(tokenPublicKey);
                const largestAccount = accounts.value[0];
                const accountInfo = await connection.getTokenAccountBalance(largestAccount.address);
                const liquidity = accountInfo.value.uiAmount;
                liquidityInfo.textContent = `Liquidity Pool Size: ${liquidity} SOL`;
                liquidityInfo.style.color = 'var(--neon-lime)';
            } catch (error) {
                console.error('Liquidity check failed:', error);
                liquidityInfo.textContent = 'Failed to fetch liquidity';
                liquidityInfo.style.color = 'var(--vibe-pink)';
            }
        }

        async function boostMemeCoinVolume(botType, tokenMint, targetVolume, walletCount, profitThreshold, form, status) {
            if (!connectedWallet) {
                status.textContent = 'Please connect your Phantom wallet first.';
                status.style.color = 'var(--vibe-pink)';
                return;
            }

            status.textContent = 'Initiating 1 SOL payment and volume boost...';
            status.style.color = 'var(--vibe-cyan)';

            try {
                const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.fm', 'confirmed');
                const walletAddress = new solanaWeb3.PublicKey('YOUR_SOLANA_WALLET_ADDRESS');
                const userPublicKey = new solanaWeb3.PublicKey(connectedWallet.address);

                const transaction = new solanaWeb3.Transaction();
                const lamports = solanaWeb3.LAMPORTS_PER_SOL * 1;
                transaction.add(
                    solanaWeb3.SystemProgram.transfer({
                        fromPubkey: userPublicKey,
                        toPubkey: walletAddress,
                        lamports: lamports,
                    })
                );

                const { blockhash } = await connection.getRecentBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = userPublicKey;

                const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signedTransaction.serialize());
                await connection.confirmTransaction(signature, 'confirmed');

                status.textContent = `Payment successful! Starting volume boost... Tx: ${signature}`;
                status.style.color = 'var(--neon-lime)';

                const wallets = [];
                for (let i = 0; i < walletCount; i++) {
                    const keypair = solanaWeb3.Keypair.generate();
                    wallets.push(keypair);
                    await connection.requestAirdrop(keypair.publicKey, solanaWeb3.LAMPORTS_PER_SOL * 0.1);
                }

                let currentVolume = 0;
                const tokenPublicKey = new solanaWeb3.PublicKey(tokenMint);

                while (currentVolume < targetVolume) {
                    for (const wallet of wallets) {
                        const buyAmount = (Math.random() * 0.05 + 0.01).toFixed(6);
                        const sellAmount = buyAmount * (Math.random() * 0.1 + 0.9);
                        const interval = Math.floor(Math.random() * 3000) + 1000;

                        const buyTx = new solanaWeb3.Transaction().add(
                            solanaWeb3.SystemProgram.transfer({
                                fromPubkey: wallet.publicKey,
                                toPubkey: tokenPublicKey,
                                lamports: solanaWeb3.LAMPORTS_PER_SOL * buyAmount
                            })
                        );
                        buyTx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;
                        buyTx.feePayer = wallet.publicKey;
                        const signedBuyTx = await wallet.signTransaction(buyTx);
                        await connection.sendRawTransaction(signedBuyTx.serialize());

                        const price = await getTokenPrice(tokenMint);
                        if (price >= profitThreshold) {
                            const sellAllTx = new solanaWeb3.Transaction().add(
                                solanaWeb3.SystemProgram.transfer({
                                    fromPubkey: wallet.publicKey,
                                    toPubkey: userPublicKey,
                                    lamports: solanaWeb3.LAMPORTS_PER_SOL * sellAmount
                                })
                            );
                            sellAllTx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;
                            sellAllTx.feePayer = wallet.publicKey;
                            const signedSellAllTx = await wallet.signTransaction(sellAllTx);
                            await connection.sendRawTransaction(signedSellAllTx.serialize());
                        }

                        currentVolume += parseFloat(buyAmount);
                        status.textContent = `Boosting volume: ${currentVolume.toFixed(2)}/${targetVolume} SOL`;
                        await new Promise(resolve => setTimeout(resolve, interval));
                    }
                }

                status.textContent = `Volume boost complete! Final Volume: ${currentVolume.toFixed(2)} SOL`;
                form.reset();
                await checkLiquidity(tokenMint);
            } catch (error) {
                console.error('Volume boost failed:', error);
                status.textContent = `Failed: ${error.message}`;
                status.style.color = 'var(--vibe-pink)';
            }
        }

        async function getTokenPrice(tokenMint) {
            return 1; // Placeholder
        }

        // Event Listeners
        const volumeBotForm = document.querySelector('.volume-bot-form');
        if (volumeBotForm) {
            volumeBotForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const botType = volumeBotForm.dataset.type;
                const tokenMint = volumeBotForm.querySelector('[name="tokenMint"]').value;
                const targetVolume = parseFloat(volumeBotForm.querySelector('[name="volume"]').value);
                const walletCount = parseInt(volumeBotForm.querySelector('[name="wallets"]').value);
                const profitThreshold = parseFloat(volumeBotForm.querySelector('[name="profitThreshold"]').value);
                const status = volumeBotForm.nextElementSibling;
                await boostMemeCoinVolume(botType, tokenMint, targetVolume, walletCount, profitThreshold, volumeBotForm, status);
            });
        }

        if (sneakerBotForm) {
            sneakerBotForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const site = sneakerBotForm.querySelector('[name="sites"]').value[0];
                const url = sneakerBotForm.querySelector('[name="url"]').value;
                const size = sneakerBotForm.querySelector('[name="size"]').value;
                const quantity = parseInt(sneakerBotForm.querySelector('[name="quantity"]').value);
                const proxies = sneakerBotForm.querySelector('[name="proxies"]').value;
                await copSneakers(site, url, size, quantity, proxies, sneakerBotStatus);
            });
        }

        console.log('Script execution completed');
    </script>
</body>
</html>